<h1 class="h1">Dynamic Programming</h1>
<p>Dynamic programming is a technique that breaks the problems into sub-problems, and saves the result for future purposes so that we do not need to compute the result again. The subproblems are optimized to optimize the overall solution is known as optimal substructure property. The main use of dynamic programming is to solve optimization problems. Here, optimization problems mean that when we are trying to find out the minimum or the maximum solution of a problem. The dynamic programming guarantees to find the optimal solution of a problem if the solution exists.</p>
<p>The definition of dynamic programming says that it is a technique for solving a complex problem by first breaking into a collection of simpler subproblems, solving each subproblem just once, and then storing their solutions to avoid repetitive computations.</p>
<p><span>Let's understand this approach through an example.</span></p>
<p><span>Consider an example of the Fibonacci series. The following series is the Fibonacci series:</span></p>
<p><span>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ,…</span></p>
<p>The numbers in the above series are not randomly calculated. Mathematically, we could write each of the terms using the below formula:</p>
<p><span>F(n) = F(n-1) + F(n-2),</span></p>
<p>With the base values F(0) = 0, and F(1) = 1. To calculate the other numbers, we follow the above relationship. For example, F(2) is the sum <span>f(0)</span> and <span>f(1),</span> which is equal to 1.</p>
<h3 class="h3">How can we calculate F(20)?</h3>
<p>The F(20) term will be calculated using the nth formula of the Fibonacci series. The below figure shows that how F(20) is calculated.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/dynamic-programming.png" alt="Dynamic Programming" /><span></span></p>
<p>As we can observe in the above figure that F(20) is calculated as the sum of F(19) and F(18). In the dynamic programming approach, we try to divide the problem into the similar subproblems. We are following this approach in the above case where F(20) into the similar subproblems, i.e., F(19) and F(18). If we recap the definition of dynamic programming that it says the similar subproblem should not be computed more than once. Still, in the above case, the subproblem is calculated twice. In the above example, F(18) is calculated two times; similarly, F(17) is also calculated twice. However, this technique is quite useful as it solves the similar subproblems, but we need to be cautious while storing the results because we are not particular about storing the result that we have computed once, then it can lead to a wastage of resources.</p>
<p>In the above example, if we calculate the F(18) in the right subtree, then it leads to the tremendous usage of resources and decreases the overall performance.</p>
<p>The solution to the above problem is to save the computed results in an array. First, we calculate F(16) and F(17) and save their values in an array. The F(18) is calculated by summing the values of F(17) and F(16), which are already saved in an array. The computed value of F(18) is saved in an array. The value of F(19) is calculated using the sum of F(18), and F(17), and their values are already saved in an array. The computed value of F(19) is stored in an array. The value of F(20) can be calculated by adding the values of F(19) and F(18), and the values of both F(19) and F(18) are stored in an array. The final computed value of F(20) is stored in an array.</p>